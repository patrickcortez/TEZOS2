#include "../include/graphics.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <math.h>

/* Graphics context structure */
struct graphics_context {
    u32* pixels;         /* RGBA pixel buffer */
    i32 width;
    i32 height;
    graphics_rect_t clip_rect;
    bool clipping_enabled;
};

/* Image structure */
struct graphics_image {
    u32* pixels;
    i32 width;
    i32 height;
};

/* Built-in 12x16 font */
struct graphics_font {
    const u8* glyphs;
    i32 glyph_width;
    i32 glyph_height;
    i32 bytes_per_row;  /* bytes needed to store one row */
};

/* Built-in 12x16 bitmap font data (ASCII 32-127)
 * Each character is 12 pixels wide, 16 pixels tall
 * 2 bytes per row (12 bits used, 4 bits padding)
 * Format: 16 rows * 2 bytes = 32 bytes per character
 */
static const u8 builtin_font_12x16[] = {
    /* Space (32) */
    0x00,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00,
    0x00,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00,
    0x00,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00,
    0x00,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00,
    /* ! (33) */
    0x00,0x00, 0x00,0x00, 0x06,0x00, 0x06,0x00,
    0x06,0x00, 0x06,0x00, 0x06,0x00, 0x06,0x00,
    0x06,0x00, 0x06,0x00, 0x00,0x00, 0x00,0x00,
    0x06,0x00, 0x06,0x00, 0x00,0x00, 0x00,0x00,
    /* " (34) */
    0x00,0x00, 0x19,0x80, 0x19,0x80, 0x19,0x80,
    0x19,0x80, 0x00,0x00, 0x00,0x00, 0x00,0x00,
    0x00,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00,
    0x00,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00,
    /* # (35) */
    0x00,0x00, 0x00,0x00, 0x0C,0xC0, 0x0C,0xC0,
    0x3F,0xF0, 0x3F,0xF0, 0x0C,0xC0, 0x0C,0xC0,
    0x3F,0xF0, 0x3F,0xF0, 0x0C,0xC0, 0x0C,0xC0,
    0x00,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00,
    /* Continue with all printable ASCII characters... */
    /* For brevity, I'll include key characters. Full font would be ~3000 bytes */
    
    /* 0 (48) - Starting from digit chars for demo */
    0x00,0x00, 0x00,0x00, 0x1F,0x80, 0x33,0xC0,
    0x33,0xC0, 0x33,0xC0, 0x33,0xC0, 0x33,0xC0,
    0x33,0xC0, 0x33,0xC0, 0x33,0xC0, 0x1F,0x80,
    0x00,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00,
    /* A (65) */
    0x00,0x00, 0x00,0x00, 0x0E,0x00, 0x1F,0x00,
    0x33,0x80, 0x33,0x80, 0x33,0x80, 0x33,0x80,
    0x3F,0x80, 0x3F,0x80, 0x33,0x80, 0x33,0x80,
   0x00,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00,
};

/* Simpler approach: Use 8x16 font (8px wide, 16px tall) for better readability */
static const u8 builtin_font_8x16[] = {
    /* Space (32) */ 
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /* ! (33) */
    0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x18,0x18,0x00,0x00,0x00,
    /* " (34) */
    0x00,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /* # (35) */
    0x00,0x00,0x6C,0x6C,0xFE,0x6C,0x6C,0x6C,0xFE,0x6C,0x6C,0x00,0x00,0x00,0x00,0x00,
    /* $ (36) */
    0x00,0x18,0x7E,0xDB,0x1B,0x1E,0x78,0xD8,0xDB,0x7E,0x18,0x00,0x00,0x00,0x00,0x00,
    /* % (37) */
    0x00,0x00,0x46,0xA6,0x4C,0x18,0x18,0x30,0x64,0xC6,0xC4,0x00,0x00,0x00,0x00,0x00,
    /* & (38) */
    0x00,0x00,0x38,0x6C,0x38,0x76,0x7E,0xCE,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00,0x00,
    /* ' (39) */
    0x00,0x18,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /* ( (40) */
    0x00,0x00,0x30,0x18,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x18,0x30,0x00,0x00,0x00,0x00,
    /* ) (41) */
    0x00,0x00,0x0C,0x18,0x30,0x30,0x30,0x30,0x30,0x30,0x18,0x0C,0x00,0x00,0x00,0x00,
    /* * (42) */
    0x00,0x00,0x00,0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /* + (43) */
    0x00,0x00,0x00,0x00,0x18,0x18,0x7E,0x7E,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00,
    /* , (44) */
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x0C,0x00,0x00,0x00,
    /* - (45) */
    0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /* . (46) */
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,
    /* / (47) */
    0x00,0x00,0x60,0x60,0x30,0x30,0x18,0x18,0x0C,0x0C,0x06,0x06,0x00,0x00,0x00,0x00,
    /* 0 (48) */
    0x00,0x00,0x3C,0x66,0xC3,0xE3,0xF3,0xDB,0xCF,0xC7,0xC3,0x66,0x3C,0x00,0x00,0x00,
    /* 1 (49) */
    0x00,0x00,0x18,0x1C,0x1E,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x7E,0x00,0x00,0x00,
    /* 2 (50) */
    0x00,0x00,0x3C,0x66,0xC3,0xC0,0x60,0x30,0x18,0x0C,0x06,0x03,0xFF,0x00,0x00,0x00,
    /* 3 (51) */
    0x00,0x00,0x3C,0x66,0xC3,0xC0,0x60,0x3C,0x60,0xC0,0xC3,0x66,0x3C,0x00,0x00,0x00,
    /* 4 (52) */
    0x00,0x00,0x60,0x70,0x78,0x6C,0x66,0x63,0xFF,0x60,0x60,0x60,0xF0,0x00,0x00,0x00,
    /* 5 (53) */
    0x00,0x00,0xFF,0x03,0x03,0x03,0x3F,0x60,0xC0,0xC0,0xC3,0x66,0x3C,0x00,0x00,0x00,
    /* 6 (54) */
    0x00,0x00,0x3C,0x66,0x03,0x03,0x3F,0x63,0xC3,0xC3,0xC3,0x66,0x3C,0x00,0x00,0x00,
    /* 7 (55) */
    0x00,0x00,0xFF,0xC0,0x60,0x30,0x18,0x18,0x0C,0x0C,0x0C,0x0C,0x0C,0x00,0x00,0x00,
    /* 8 (56) */
    0x00,0x00,0x3C,0x66,0xC3,0xC3,0x66,0x3C,0x66,0xC3,0xC3,0x66,0x3C,0x00,0x00,0x00,
    /* 9 (57) */
    0x00,0x00,0x3C,0x66,0xC3,0xC3,0xC3,0xE6,0xFC,0xC0,0xC0,0x66,0x3C,0x00,0x00,0x00,
    /* : (58) */
    0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00,
    /* ; (59) */
    0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x0C,0x00,0x00,0x00,0x00,
    /* < (60) */
    0x00,0x00,0x00,0x60,0x30,0x18,0x0C,0x06,0x0C,0x18,0x30,0x60,0x00,0x00,0x00,0x00,
    /* = (61) */
    0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /* > (62) */
    0x00,0x00,0x00,0x06,0x0C,0x18,0x30,0x60,0x30,0x18,0x0C,0x06,0x00,0x00,0x00,0x00,
    /* ? (63) */
    0x00,0x00,0x3C,0x66,0xC3,0xC0,0x60,0x30,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,
    /* @ (64) */
    0x00,0x00,0x3C,0x66,0xC3,0xF3,0xDB,0xDB,0xDB,0xF3,0x03,0x06,0x3C,0x00,0x00,0x00,
    /* A (65) */
    0x00,0x00,0x18,0x3C,0x66,0x66,0xC3,0xC3,0xFF,0xC3,0xC3,0xC3,0xC3,0x00,0x00,0x00,
    /* B (66) */
    0x00,0x00,0x3F,0x66,0xC3,0xC3,0x66,0x3E,0x66,0xC3,0xC3,0x66,0x3F,0x00,0x00,0x00,
    /* C (67) */
    0x00,0x00,0x3C,0x66,0xC3,0x03,0x03,0x03,0x03,0x03,0xC3,0x66,0x3C,0x00,0x00,0x00,
    /* D (68) */
    0x00,0x00,0x3F,0x66,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0x66,0x3F,0x00,0x00,0x00,
    /* E (69) */
    0x00,0x00,0xFF,0x03,0x03,0x03,0x03,0x3F,0x03,0x03,0x03,0x03,0xFF,0x00,0x00,0x00,
    /* F (70) */
    0x00,0x00,0xFF,0x03,0x03,0x03,0x03,0x3F,0x03,0x03,0x03,0x03,0x03,0x00,0x00,0x00,
    /* G (71) */
    0x00,0x00,0x3C,0x66,0xC3,0x03,0x03,0xF3,0xC3,0xC3,0xC3,0x66,0x3C,0x00,0x00,0x00,
    /* H (72) */
    0x00,0x00,0xC3,0xC3,0xC3,0xC3,0xC3,0xFF,0xC3,0xC3,0xC3,0xC3,0xC3,0x00,0x00,0x00,
    /* I (73) */
    0x00,0x00,0x7E,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x7E,0x00,0x00,0x00,
    /* J (74) */
    0x00,0x00,0xFC,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x63,0x66,0x3C,0x00,0x00,0x00,
    /* K (75) */
    0x00,0x00,0xC3,0x63,0x33,0x1B,0x0F,0x07,0x0F,0x1B,0x33,0x63,0xC3,0x00,0x00,0x00,
    /* L (76) */
    0x00,0x00,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0xFF,0x00,0x00,0x00,
    /* M (77) */
    0x00,0x00,0xC3,0xE7,0xFF,0xDB,0xDB,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0x00,0x00,0x00,
    /* N (78) */
    0x00,0x00,0xC3,0xC7,0xCF,0xDB,0xF3,0xE3,0xC3,0xC3,0xC3,0xC3,0xC3,0x00,0x00,0x00,
    /* O (79) */
    0x00,0x00,0x3C,0x66,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0x66,0x3C,0x00,0x00,0x00,
    /* P (80) */
    0x00,0x00,0x3F,0x66,0xC3,0xC3,0xC3,0x66,0x3F,0x03,0x03,0x03,0x03,0x00,0x00,0x00,
    /* Q (81) */
    0x00,0x00,0x3C,0x66,0xC3,0xC3,0xC3,0xC3,0xC3,0xDB,0xF3,0x66,0xBC,0xC0,0x00,0x00,
    /* R (82) */
    0x00,0x00,0x3F,0x66,0xC3,0xC3,0xC3,0x66,0x3F,0x1B,0x33,0x63,0xC3,0x00,0x00,0x00,
    /* S (83) */
    0x00,0x00,0x3C,0x66,0xC3,0x03,0x06,0x3C,0x60,0xC0,0xC3,0x66,0x3C,0x00,0x00,0x00,
    /* T (84) */
    0x00,0x00,0xFF,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,
    /* U (85) */
    0x00,0x00,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0x66,0x3C,0x00,0x00,0x00,
    /* V (86) */
    0x00,0x00,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0x66,0x3C,0x18,0x00,0x00,0x00,0x00,
    /* W (87) */
    0x00,0x00,0xC3,0xC3,0xC3,0xC3,0xC3,0xDB,0xDB,0xFF,0xE7,0xC3,0x00,0x00,0x00,0x00,
    /* X (88) */
    0x00,0x00,0xC3,0x66,0x3C,0x18,0x18,0x18,0x18,0x3C,0x66,0xC3,0x00,0x00,0x00,0x00,
    /* Y (89) */
    0x00,0x00,0xC3,0xC3,0x66,0x3C,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,
    /* Z (90) */
    0x00,0x00,0xFF,0xC0,0x60,0x30,0x18,0x18,0x0C,0x06,0x03,0x03,0xFF,0x00,0x00,0x00,
    /* [ (91) */
    0x00,0x00,0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00,0x00,0x00,
    /* \ (92) */
    0x00,0x00,0x06,0x06,0x0C,0x0C,0x18,0x18,0x30,0x30,0x60,0x60,0x00,0x00,0x00,0x00,
    /* ] (93) */
    0x00,0x00,0x3C,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x3C,0x00,0x00,0x00,
    /* ^ (94) */
    0x00,0x18,0x3C,0x66,0xC3,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /* _ (95) */
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,
    /* ` (96) */
    0x00,0x0C,0x18,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /* a (97) */
    0x00,0x00,0x00,0x00,0x00,0x3C,0x60,0x7C,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00,
    /* b (98) */
    0x00,0x00,0x06,0x06,0x06,0x3E,0x66,0xC6,0xC6,0xC6,0x66,0x3E,0x00,0x00,0x00,0x00,
    /* c (99) */
    0x00,0x00,0x00,0x00,0x00,0x3C,0x66,0x06,0x06,0x06,0x66,0x3C,0x00,0x00,0x00,0x00,
    /* d (100) */
    0x00,0x00,0x60,0x60,0x60,0x7C,0x66,0xC6,0xC6,0xC6,0x66,0x7C,0x00,0x00,0x00,0x00,
    /* e (101) */
    0x00,0x00,0x00,0x00,0x00,0x3C,0x66,0xC6,0xFE,0x06,0x66,0x3C,0x00,0x00,0x00,0x00,
    /* f (102) */
    0x00,0x00,0x38,0x6C,0x0C,0x0C,0x3E,0x0C,0x0C,0x0C,0x0C,0x0C,0x00,0x00,0x00,0x00,
    /* g (103) */
    0x00,0x00,0x00,0x00,0x00,0x7C,0x66,0xC6,0xC6,0xC6,0x66,0x7C,0x60,0x66,0x3C,0x00,
    /* h (104) */
    0x00,0x00,0x06,0x06,0x06,0x3E,0x66,0xC6,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00,
    /* i (105) */
    0x00,0x00,0x18,0x18,0x00,0x1C,0x18,0x18,0x18,0x18,0x18,0x7E,0x00,0x00,0x00,0x00,
    /* j (106) */
    0x00,0x00,0x30,0x30,0x00,0x38,0x30,0x30,0x30,0x30,0x30,0x30,0x33,0x33,0x1E,0x00,
    /* k (107) */
    0x00,0x00,0x06,0x06,0x06,0x66,0x36,0x1E,0x1E,0x36,0x66,0xC6,0x00,0x00,0x00,0x00,
    /* l (108) */
    0x00,0x00,0x1C,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x7E,0x00,0x00,0x00,0x00,
    /* m (109) */
    0x00,0x00,0x00,0x00,0x00,0x6E,0xFE,0xD6,0xD6,0xD6,0xC6,0xC6,0x00,0x00,0x00,0x00,
    /* n (110) */
    0x00,0x00,0x00,0x00,0x00,0x3E,0x66,0xC6,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00,
    /* o (111) */
    0x00,0x00,0x00,0x00,0x00,0x3C,0x66,0xC6,0xC6,0xC6,0x66,0x3C,0x00,0x00,0x00,0x00,
    /* p (112) */
    0x00,0x00,0x00,0x00,0x00,0x3E,0x66,0xC6,0xC6,0xC6,0x66,0x3E,0x06,0x06,0x06,0x00,
    /* q (113) */
    0x00,0x00,0x00,0x00,0x00,0x7C,0x66,0xC6,0xC6,0xC6,0x66,0x7C,0x60,0x60,0x60,0x00,
    /* r (114) */
    0x00,0x00,0x00,0x00,0x00,0x76,0x7E,0x0E,0x06,0x06,0x06,0x06,0x00,0x00,0x00,0x00,
    /* s (115) */
    0x00,0x00,0x00,0x00,0x00,0x3C,0x66,0x06,0x3C,0x60,0x66,0x3C,0x00,0x00,0x00,0x00,
    /* t (116) */
    0x00,0x00,0x00,0x0C,0x0C,0x3E,0x0C,0x0C,0x0C,0x0C,0x6C,0x38,0x00,0x00,0x00,0x00,
    /* u (117) */
    0x00,0x00,0x00,0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0x66,0x7C,0x00,0x00,0x00,0x00,
    /* v (118) */
    0x00,0x00,0x00,0x00,0x00,0xC3,0xC3,0xC3,0x66,0x66,0x3C,0x18,0x00,0x00,0x00,0x00,
    /* w (119) */
    0x00,0x00,0x00,0x00,0x00,0xC6,0xC6,0xD6,0xD6,0xD6,0xFE,0x6C,0x00,0x00,0x00,0x00,
    /* x (120) */
    0x00,0x00,0x00,0x00,0x00,0xC6,0x6C,0x38,0x38,0x38,0x6C,0xC6,0x00,0x00,0x00,0x00,
    /* y (121) */
    0x00,0x00,0x00,0x00,0x00,0xC3,0xC3,0xC3,0x66,0x3C,0x18,0x18,0x0C,0x06,0x03,0x00,
    /* z (122) */
    0x00,0x00,0x00,0x00,0x00,0xFE,0x60,0x30,0x18,0x0C,0x06,0xFE,0x00,0x00,0x00,0x00,
    /* { (123) */
    0x00,0x00,0x70,0x18,0x18,0x18,0x0C,0x06,0x0C,0x18,0x18,0x18,0x70,0x00,0x00,0x00,
    /* | (124) */
    0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,
    /* } (125) */
    0x00,0x00,0x0E,0x18,0x18,0x18,0x30,0x60,0x30,0x18,0x18,0x18,0x0E,0x00,0x00,0x00,
    /* ~ (126) */
    0x00,0x00,0x00,0x00,0x00,0x00,0x76,0xDC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /* DEL (127) - shown as filled block */
    0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,
};

static graphics_font_t g_default_font = {
    .glyphs = builtin_font_8x16,
    .glyph_width = 8,
    .glyph_height = 16,
    .bytes_per_row = 1  /* 8 bits = 1 byte per row */
};

/* Helper: Pack RGBA into u32 */
static inline u32 pack_color(graphics_color_t c) {
    return (c.a << 24) | (c.b << 16) | (c.g << 8) | c.r;
}

/* Helper: Unpack u32 into RGBA */
static inline graphics_color_t unpack_color(u32 packed) {
    graphics_color_t c;
    c.r = packed & 0xFF;
    c.g = (packed >> 8) & 0xFF;
    c.b = (packed >> 16) & 0xFF;
    c.a = (packed >> 24) & 0xFF;
    return c;
}

/* Helper: Alpha blend */
static inline u32 blend_colors(u32 src, u32 dst) {
    graphics_color_t s = unpack_color(src);
    graphics_color_t d = unpack_color(dst);
    
    if (s.a == 255) return src;
    if (s.a == 0) return dst;
    
    u32 alpha = s.a + 1;
    u32 inv_alpha = 256 - s.a;
    
    graphics_color_t result;
    result.r = (s.r * alpha + d.r * inv_alpha) >> 8;
    result.g = (s.g * alpha + d.g * inv_alpha) >> 8;
    result.b = (s.b * alpha + d.b * inv_alpha) >> 8;
    result.a = 255;
    
    return pack_color(result);
}

/* Color creation */
graphics_color_t graphics_rgb(u8 r, u8 g, u8 b) {
    graphics_color_t c = {r, g, b, 255};
    return c;
}

graphics_color_t graphics_rgba(u8 r, u8 g, u8 b, u8 a) {
    graphics_color_t c = {r, g, b, a};
    return c;
}

graphics_color_t graphics_hex(u32 hex) {
    graphics_color_t c;
    c.r = (hex >> 16) & 0xFF;
    c.g = (hex >> 8) & 0xFF;
    c.b = hex & 0xFF;
    c.a = 255;
    return c;
}

/* Context management */
graphics_context_t* graphics_create_context(i32 width, i32 height) {
    if (width <= 0 || height <= 0) {
        ENGINE_LOG_ERROR("Invalid context dimensions");
        return NULL;
    }
    
    graphics_context_t* ctx = (graphics_context_t*)malloc(sizeof(graphics_context_t));
    if (!ctx) {
        ENGINE_LOG_ERROR("Failed to allocate graphics context");
        return NULL;
    }
    
    ctx->pixels = (u32*)calloc(width * height, sizeof(u32));
    if (!ctx->pixels) {
        ENGINE_LOG_ERROR("Failed to allocate pixel buffer");
        free(ctx);
        return NULL;
    }
    
    ctx->width = width;
    ctx->height = height;
    ctx->clipping_enabled = false;
    ctx->clip_rect = graphics_rect(0, 0, width, height);
    
    ENGINE_LOG_INFO("Graphics context created: %dx%d", width, height);
    return ctx;
}

void graphics_destroy_context(graphics_context_t* ctx) {
    if (!ctx) return;
    
    if (ctx->pixels) {
        free(ctx->pixels);
    }
    free(ctx);
    ENGINE_LOG_INFO("Graphics context destroyed");
}

i32 graphics_get_width(const graphics_context_t* ctx) {
    return ctx ? ctx->width : 0;
}

i32 graphics_get_height(const graphics_context_t* ctx) {
    return ctx ? ctx->height : 0;
}

void graphics_resize(graphics_context_t* ctx, i32 width, i32 height) {
    if (!ctx || width <= 0 || height <= 0) return;
    
    u32* new_pixels = (u32*)calloc(width * height, sizeof(u32));
    if (!new_pixels) {
        ENGINE_LOG_ERROR("Failed to resize graphics context");
        return;
    }
    
    free(ctx->pixels);
    ctx->pixels = new_pixels;
    ctx->width = width;
    ctx->height = height;
    ctx->clip_rect = graphics_rect(0, 0, width, height);
}

/* Rendering control */
void graphics_clear(graphics_context_t* ctx, graphics_color_t color) {
    if (!ctx) return;
    
    u32 packed = pack_color(color);
    for (i32 i = 0; i < ctx->width * ctx->height; i++) {
        ctx->pixels[i] = packed;
    }
}

void graphics_set_clip_rect(graphics_context_t* ctx, const graphics_rect_t* rect) {
    if (!ctx || !rect) return;
    
    ctx->clip_rect = *rect;
    ctx->clipping_enabled = true;
}

void graphics_clear_clip_rect(graphics_context_t* ctx) {
    if (!ctx) return;
    
    ctx->clip_rect = graphics_rect(0, 0, ctx->width, ctx->height);
    ctx->clipping_enabled = false;
}

/* Drawing primitives */
void graphics_draw_pixel(graphics_context_t* ctx, i32 x, i32 y, graphics_color_t color) {
    if (!ctx) return;
    
    /* Clipping */
    if (ctx->clipping_enabled) {
        if (x < ctx->clip_rect.x || x >= ctx->clip_rect.x + ctx->clip_rect.width ||
            y < ctx->clip_rect.y || y >= ctx->clip_rect.y + ctx->clip_rect.height) {
            return;
        }
    } else {
        if (x < 0 || x >= ctx->width || y < 0 || y >= ctx->height) {
            return;
        }
    }
    
    u32 packed = pack_color(color);
    if (color.a == 255) {
        ctx->pixels[y * ctx->width + x] = packed;
    } else {
        ctx->pixels[y * ctx->width + x] = blend_colors(packed, ctx->pixels[y * ctx->width + x]);
    }
}

void graphics_draw_line(graphics_context_t* ctx, i32 x1, i32 y1, i32 x2, i32 y2, graphics_color_t color) {
    if (!ctx) return;
    
    /* Bresenham's line algorithm */
    i32 dx = abs(x2 - x1);
    i32 dy = abs(y2 - y1);
    i32 sx = x1 < x2 ? 1 : -1;
    i32 sy = y1 < y2 ? 1 : -1;
    i32 err = dx - dy;
    
    while (1) {
        graphics_draw_pixel(ctx, x1, y1, color);
        
        if (x1 == x2 && y1 == y2) break;
        
        i32 e2 = 2 * err;
        if (e2 > -dy) {
            err -= dy;
            x1 += sx;
        }
        if (e2 < dx) {
            err += dx;
            y1 += sy;
        }
    }
}

void graphics_draw_rect(graphics_context_t* ctx, const graphics_rect_t* rect, graphics_color_t color) {
    if (!ctx || !rect) return;
    
    /* Draw four lines */
    graphics_draw_line(ctx, rect->x, rect->y, rect->x + rect->width - 1, rect->y, color);
    graphics_draw_line(ctx, rect->x + rect->width - 1, rect->y, rect->x + rect->width - 1, rect->y + rect->height - 1, color);
    graphics_draw_line(ctx, rect->x + rect->width - 1, rect->y + rect->height - 1, rect->x, rect->y + rect->height - 1, color);
    graphics_draw_line(ctx, rect->x, rect->y + rect->height - 1, rect->x, rect->y, color);
}

void graphics_fill_rect(graphics_context_t* ctx, const graphics_rect_t* rect, graphics_color_t color) {
    if (!ctx || !rect) return;
    
    i32 x1 = rect->x;
    i32 y1 = rect->y;
    i32 x2 = rect->x + rect->width;
    i32 y2 = rect->y + rect->height;
    
    /* Clip to clipping rect if enabled, otherwise to context bounds */
    if (ctx->clipping_enabled) {
        if (x1 < ctx->clip_rect.x) x1 = ctx->clip_rect.x;
        if (y1 < ctx->clip_rect.y) y1 = ctx->clip_rect.y;
        if (x2 > ctx->clip_rect.x + ctx->clip_rect.width) x2 = ctx->clip_rect.x + ctx->clip_rect.width;
        if (y2 > ctx->clip_rect.y + ctx->clip_rect.height) y2 = ctx->clip_rect.y + ctx->clip_rect.height;
    } else {
        if (x1 < 0) x1 = 0;
        if (y1 < 0) y1 = 0;
        if (x2 > ctx->width) x2 = ctx->width;
        if (y2 > ctx->height) y2 = ctx->height;
    }
    
    /* Early exit if clipped out entirely */
    if (x1 >= x2 || y1 >= y2) return;
    
    u32 packed = pack_color(color);
    
    for (i32 y = y1; y < y2; y++) {
        for (i32 x = x1; x < x2; x++) {
            if (color.a == 255) {
                ctx->pixels[y * ctx->width + x] = packed;
            } else {
                ctx->pixels[y * ctx->width + x] = blend_colors(packed, ctx->pixels[y * ctx->width + x]);
            }
        }
    }
}

void graphics_draw_circle(graphics_context_t* ctx, i32 cx, i32 cy, i32 radius, graphics_color_t color) {
    if (!ctx || radius < 0) return;
    
    /* Midpoint circle algorithm */
    i32 x = radius;
    i32 y = 0;
    i32 err = 0;
    
    while (x >= y) {
        graphics_draw_pixel(ctx, cx + x, cy + y, color);
        graphics_draw_pixel(ctx, cx + y, cy + x, color);
        graphics_draw_pixel(ctx, cx - y, cy + x, color);
        graphics_draw_pixel(ctx, cx - x, cy + y, color);
        graphics_draw_pixel(ctx, cx - x, cy - y, color);
        graphics_draw_pixel(ctx, cx - y, cy - x, color);
        graphics_draw_pixel(ctx, cx + y, cy - x, color);
        graphics_draw_pixel(ctx, cx + x, cy - y, color);
        
        if (err <= 0) {
            y += 1;
            err += 2 * y + 1;
        }
        if (err > 0) {
            x -= 1;
            err -= 2 * x + 1;
        }
    }
}

void graphics_fill_circle(graphics_context_t* ctx, i32 cx, i32 cy, i32 radius, graphics_color_t color) {
    if (!ctx || radius < 0) return;
    
    /* Scanline circle fill */
    i32 x = radius;
    i32 y = 0;
    i32 err = 0;
    
    while (x >= y) {
        /* Draw horizontal lines */
        for (i32 i = cx - x; i <= cx + x; i++) {
            graphics_draw_pixel(ctx, i, cy + y, color);
            graphics_draw_pixel(ctx, i, cy - y, color);
        }
        for (i32 i = cx - y; i <= cx + y; i++) {
            graphics_draw_pixel(ctx, i, cy + x, color);
            graphics_draw_pixel(ctx, i, cy - x, color);
        }
        
        if (err <= 0) {
            y += 1;
            err += 2 * y + 1;
        }
        if (err > 0) {
            x -= 1;
            err -= 2 * x + 1;
        }
    }
}

void graphics_draw_triangle(graphics_context_t* ctx, i32 x1, i32 y1, i32 x2, i32 y2, i32 x3, i32 y3, graphics_color_t color) {
    if (!ctx) return;
    
    graphics_draw_line(ctx, x1, y1, x2, y2, color);
    graphics_draw_line(ctx, x2, y2, x3, y3, color);
    graphics_draw_line(ctx, x3, y3, x1, y1, color);
}

void graphics_fill_triangle(graphics_context_t* ctx, i32 x1, i32 y1, i32 x2, i32 y2, i32 x3, i32 y3, graphics_color_t color) {
    if (!ctx) return;
    
    /* Simple scanline triangle fill */
    /* Sort vertices by y-coordinate */
    if (y1 > y2) { i32 tmp = y1; y1 = y2; y2 = tmp; tmp = x1; x1 = x2; x2 = tmp; }
    if (y1 > y3) { i32 tmp = y1; y1 = y3; y3 = tmp; tmp = x1; x1 = x3; x3 = tmp; }
    if (y2 > y3) { i32 tmp = y2; y2 = y3; y3 = tmp; tmp = x2; x2 = x3; x3 = tmp; }
    
    /* Scanline fill */
    for (i32 y = y1; y <= y3; y++) {
        i32 xa, xb;
        
        if (y < y2) {
            xa = y1 != y2 ? x1 + (x2 - x1) * (y - y1) / (y2 - y1) : x1;
        } else {
            xa = y2 != y3 ? x2 + (x3 - x2) * (y - y2) / (y3 - y2) : x2;
        }
        
        xb = y1 != y3 ? x1 + (x3 - x1) * (y - y1) / (y3 - y1) : x1;
        
        if (xa > xb) { i32 tmp = xa; xa = xb; xb = tmp; }
        
        for (i32 x = xa; x <= xb; x++) {
            graphics_draw_pixel(ctx, x, y, color);
        }
    }
}

/* Text rendering */
graphics_font_t* graphics_get_default_font(void) {
    return &g_default_font;
}

void graphics_draw_text(graphics_context_t* ctx, const char* text, i32 x, i32 y, graphics_color_t color, graphics_font_t* font) {
    if (!ctx || !text) return;
    if (!font) font = &g_default_font;
    
    i32 start_x = x;
    
    for (const char* p = text; *p; p++) {
        i32 ch = (i32)(*p);
        
        if (ch == '\n') {
            y += font->glyph_height;
            x = start_x;
            continue;
        }
        
        if (ch < 32 || ch > 126) {
            ch = '?';
        }
        
        /* Get glyph data */
        i32 glyph_index = ch - 32;
        const u8* glyph = font->glyphs + (glyph_index * font->glyph_height);
        
        /* Draw glyph */
        for (i32 row = 0; row < font->glyph_height; row++) {
            u8 byte = glyph[row];
            for (i32 col = 0; col < font->glyph_width; col++) {
                /* Read bits from right to left (LSB to MSB) */
                if (byte & (1 << col)) {
                    graphics_draw_pixel(ctx, x + col, y + row, color);
                }
            }
        }
        
        x += font->glyph_width;
    }
}

void graphics_measure_text(const char* text, graphics_font_t* font, i32* out_width, i32* out_height) {
    if (!text) {
        if (out_width) *out_width = 0;
        if (out_height) *out_height = 0;
        return;
    }
    
    if (!font) font = &g_default_font;
    
    i32 width = 0;
    i32 height = font->glyph_height;
    i32 line_width = 0;
    
    for (const char* p = text; *p; p++) {
        if (*p == '\n') {
            height += font->glyph_height;
            if (line_width > width) width = line_width;
            line_width = 0;
        } else {
            line_width += font->glyph_width;
        }
    }
    
    if (line_width > width) width = line_width;
    
    if (out_width) *out_width = width;
    if (out_height) *out_height = height;
}

/* Direct pixel access */
u32* graphics_get_pixels(graphics_context_t* ctx) {
    return ctx ? ctx->pixels : NULL;
}

void graphics_set_pixels(graphics_context_t* ctx, const u32* pixels) {
    if (!ctx || !pixels) return;
    memcpy(ctx->pixels, pixels, ctx->width * ctx->height * sizeof(u32));
}

/* Helper functions */
graphics_rect_t graphics_rect(i32 x, i32 y, i32 width, i32 height) {
    graphics_rect_t r = {x, y, width, height};
    return r;
}

graphics_point_t graphics_point(i32 x, i32 y) {
    graphics_point_t p = {x, y};
    return p;
}

bool graphics_rect_contains_point(const graphics_rect_t* rect, i32 x, i32 y) {
    if (!rect) return false;
    return x >= rect->x && x < rect->x + rect->width &&
           y >= rect->y && y < rect->y + rect->height;
}

bool graphics_rect_intersects(const graphics_rect_t* a, const graphics_rect_t* b) {
    if (!a || !b) return false;
    return a->x < b->x + b->width && a->x + a->width > b->x &&
           a->y < b->y + b->height && a->y + a->height > b->y;
}

/* Image operations - BMP Loading */
graphics_image_t* graphics_load_image(const char* filename) {
    if (!filename) {
        ENGINE_LOG_ERROR("Invalid filename");
        return NULL;
    }
    
    FILE* fp = fopen(filename, "rb");
    if (!fp) {
        ENGINE_LOG_ERROR("Failed to open image file: %s", filename);
        return NULL;
    }
    
    /* Read BMP header (14 bytes) */
    u8 header[54];
    if (fread(header, 1, 54, fp) != 54) {
        ENGINE_LOG_ERROR("Invalid BMP file (header too small)");
        fclose(fp);
        return NULL;
    }
    
    /* Check BMP signature */
    if (header[0] != 'B' || header[1] != 'M') {
        ENGINE_LOG_ERROR("Not a BMP file");
        fclose(fp);
        return NULL;
    }
    
    /* Extract image info */
    u32 data_offset = *(u32*)&header[10];
    i32 width = *(i32*)&header[18];
    i32 height = *(i32*)&header[22];
    u16 bits_per_pixel = *(u16*)&header[28];
    u32 compression = *(u32*)&header[30];
    
    /* Handle negative height (top-down bitmap) */
    bool top_down = false;
    if (height < 0) {
        height = -height;
        top_down = true;
    }
    
    /* Validate */
    if (width <= 0 || height <= 0) {
        ENGINE_LOG_ERROR("Invalid BMP dimensions: %dx%d", width, height);
        fclose(fp);
        return NULL;
    }
    
    if (compression != 0) {
        ENGINE_LOG_ERROR("Compressed BMP not supported");
        fclose(fp);
        return NULL;
    }
    
    if (bits_per_pixel != 24 && bits_per_pixel != 32) {
        ENGINE_LOG_ERROR("Only 24-bit and 32-bit BMP supported, got %d-bit", bits_per_pixel);
        fclose(fp);
        return NULL;
    }
    
    /* Create image */
    graphics_image_t* image = graphics_create_image(width, height);
    if (!image) {
        ENGINE_LOG_ERROR("Failed to allocate image");
        fclose(fp);
        return NULL;
    }
    
    /* Seek to pixel data */
    fseek(fp, data_offset, SEEK_SET);
    
    /* BMP rows are padded to multiples of 4 bytes */
    i32 bytes_per_pixel = bits_per_pixel / 8;
    i32 row_size = width * bytes_per_pixel;
    i32 padded_row_size = (row_size + 3) & ~3;  /* Round up to multiple of 4 */
    
    u8* row_buffer = (u8*)malloc(padded_row_size);
    if (!row_buffer) {
        ENGINE_LOG_ERROR("Failed to allocate row buffer");
        graphics_destroy_image(image);
        fclose(fp);
        return NULL;
    }
    
    /* Read pixels (BMP is bottom-up by default) */
    for (i32 y = 0; y < height; y++) {
        /* Calculate destination row (flip if bottom-up) */
        i32 dest_y = top_down ? y : (height - 1 - y);
        
        if (fread(row_buffer, 1, padded_row_size, fp) != (size_t)padded_row_size) {
            ENGINE_LOG_ERROR("Failed to read image data at row %d", y);
            free(row_buffer);
            graphics_destroy_image(image);
            fclose(fp);
            return NULL;
        }
        
        /* Convert pixels to RGBA */
        for (i32 x = 0; x < width; x++) {
            i32 src_offset = x * bytes_per_pixel;
            
            u8 b = row_buffer[src_offset + 0];
            u8 g = row_buffer[src_offset + 1];
            u8 r = row_buffer[src_offset + 2];
            u8 a = (bits_per_pixel == 32) ? row_buffer[src_offset + 3] : 255;
            
            /* Pack into RGBA32 */
            image->pixels[dest_y * width + x] = (a << 24) | (b << 16) | (g << 8) | r;
        }
    }
    
    free(row_buffer);
    fclose(fp);
    
    ENGINE_LOG_INFO("Loaded BMP image: %s (%dx%d, %d-bit)", filename, width, height, bits_per_pixel);
    return image;
}

graphics_image_t* graphics_create_image(i32 width, i32 height) {
    if (width <= 0 || height <= 0) return NULL;
    
    graphics_image_t* image = (graphics_image_t*)malloc(sizeof(graphics_image_t));
    if (!image) return NULL;
    
    image->pixels = (u32*)calloc(width * height, sizeof(u32));
    if (!image->pixels) {
        free(image);
        return NULL;
    }
    
    image->width = width;
    image->height = height;
    return image;
}

void graphics_destroy_image(graphics_image_t* image) {
    if (!image) return;
    if (image->pixels) free(image->pixels);
    free(image);
}

void graphics_draw_image(graphics_context_t* ctx, const graphics_image_t* image, i32 x, i32 y) {
    if (!ctx || !image) return;
    
    for (i32 row = 0; row < image->height; row++) {
        for (i32 col = 0; col < image->width; col++) {
            u32 pixel = image->pixels[row * image->width + col];
            graphics_color_t color = unpack_color(pixel);
            graphics_draw_pixel(ctx, x + col, y + row, color);
        }
    }
}

void graphics_draw_image_scaled(graphics_context_t* ctx, const graphics_image_t* image, const graphics_rect_t* dest) {
    if (!ctx || !image || !dest) return;
    
    /* Simple nearest-neighbor scaling */
    for (i32 dy = 0; dy < dest->height; dy++) {
        for (i32 dx = 0; dx < dest->width; dx++) {
            i32 sx = dx * image->width / dest->width;
            i32 sy = dy * image->height / dest->height;
            u32 pixel = image->pixels[sy * image->width + sx];
            graphics_color_t color = unpack_color(pixel);
            graphics_draw_pixel(ctx, dest->x + dx, dest->y + dy, color);
        }
    }
}

i32 graphics_image_get_width(const graphics_image_t* image) {
    return image ? image->width : 0;
}

i32 graphics_image_get_height(const graphics_image_t* image) {
    return image ? image->height : 0;
}
